---
title: "03 - Time in Distributed Systems"
geekdocDescription: ""
keywords: ["distributed computing", "omscs", "logical time", "vector clock"]
---
## Introduction

- Distributed Systems cannot rely on Physical Clocks so they rely on Logical Clocks

## Why Do We Need Time

- There are many scenarios in which knowing the time can be helpful. For eg. checking the correctness of the program. Same operations executed in different
    - Determining the order of operations executing in the system
    - Checking correctness of the final state with the expected final state

## Why Is Measuring Time Hard in DS?

- Option 1: Why can't we use local clock on each node to record the time
    - Good: Since each message is timestamped, there is a global order of all the events
    - Bad: It's impossible to precisely synchronise all the local clocks
- Option 2: Let there be a receiver/observer node. Every node in the system sends it a message when an event occurs on that node.
    - Due to unpredictable delays, message can arrive at the observer out of order
    - Different Observers can report different order of events

## Logical Time

- Logical clocks, unlike physical clocks, progress only when an event occurs and usually provides a distinct timestamp to each event.
- Types of clocks (details left out in lecture)
    - Scalar Clock / Lamport Clocks
    - Vector Clocks
    - Matrix Clocks

## Common Notation

- There are three type of events : send of a msg, recv of a msg and internal events in a node
- Note that when a msg is send from node n1 to node n2, two events occur : n1 registers send(msg) event while n2 registers recv(msg) event.
- e1 → e2 implies, e1 "happened before" e2
- All events on a single node are ordered
- If a node receives a msg (e1) and sends it (e2) , then e1 → e2
- If a node sends a msg (e1) and it is recvd by another node(e2), then e1 → e2

## Concurrent Events

- If e1 and e2 are not related by "happened before" relationship, we call them concurrent. Is means that we cannot conclusively state the order in which those events occurred. e1 || e2

## Logical Clocks

- Timestamps generated by logical clocks need to guarantee some properties to be useful
- Clock Consistency Condition
    - e1 → e2 then, C(e1) < C(e2)
    - Monotonicity property, logical clocks must always increase
    - Note that C(e1) < C(e2) does not imply e1 → e2
- e1 || e2 then, C(e1) ?? C(e2)
    - For concurrent events, there are no guarantees, the logical timestamps can be in any order or they may simply be uncomparable
- Strong Clock Consistency (not mandatory for all logical clocks)
    - e1 → e2 ⇔ C(e1) < C(e2)
- A logical clock defines a set of rules on how to advance it and how to compare two timestamps.

## Lamport's Scalar Clock

- Each process had it's own local logical clock
- Rules

![Lamport Scalar Clock](/cs7210/lectures/lecture03/image6.png)

## Vector Clocks (vt)

- Lamport Clock does not satisfy the Strong Clock Consistency
- Size of clock is equal to number of processes in the system
- If vt is the vector clock at a process, then vt[i] represents that process's view of time of ith process.
- Rules
    ![Vector Clocks 1](/cs7210/lectures/lecture03/image5.png)
    
- Comparison Rules

![Vector Clocks 1](/cs7210/lectures/lecture03/image4.png)

## Matrix Clocks

- Each process maintain N x N matrix
- Consider process Pi,
    - i-th row of matrix corresponds to Pi's own vector clock
    - j-th row (other than i) corresponds to Pi's view of Pj 's vector clock
- Benefits
    - A process can know if the vector clock of every other process has progressed past a certain time, t.
    - This can be used to delete any data which is cached for processed which are falling behind.