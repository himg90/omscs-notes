<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CS7210 - Distributed Computing</title><link>https://www.digestnotes.com/</link><description>Recent content on CS7210 - Distributed Computing</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://www.digestnotes.com/index.xml" rel="self" type="application/rss+xml"/><item><title>03 - Time in D. Systems</title><link>https://www.digestnotes.com/lectures/lecture03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/lectures/lecture03/</guid><description>Introduction Distributed Systems cannot rely on Physical Clocks so they rely on Logical Clocks Why Do We Need Time There are many scenarios in which knowing the time can be helpful. For eg. checking the correctness of the program. Same operations executed in different Determining the order of operations executing in the system Checking correctness of the final state with the expected final state Why Is Measuring Time Hard in DS?</description></item><item><title>04 - State in D. Systems</title><link>https://www.digestnotes.com/lectures/lecture04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/lectures/lecture04/</guid><description>Introduction Study challenges in maintaining state in a distributed system. Study capturing of snapshot of the global state of the Distributed System. This helps to understand what&amp;rsquo;s happening in the system and to calculate its properties Chandy - Lamport Algorithm Global State, Snapshots and Other Terminology Distributed system consists of a set of processes and communication channels between them. A Process has a series of events occurring.</description></item><item><title>05 - Consensus</title><link>https://www.digestnotes.com/lectures/lecture05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/lectures/lecture05/</guid><description>Link to Lecture Slides
Paper Trail: A Brief Tour of FLP Impossibility
Consensus What is Consensus? Ability of processes in a distributed processes to agree on something like the value of a variable current timestamp or point of computation taking an action etc. Why is it important? Important to make forward progress in distributed system. Reaching a consensus makes it possible for the system to be correct.</description></item><item><title>06 - Replication</title><link>https://www.digestnotes.com/lectures/lecture06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/lectures/lecture06/</guid><description>Goals of Replication State available at more than one node =&amp;gt; Fault-tolerance, Availability Service can be provided from more than one node =&amp;gt; Scalability Replication Modes Active Replication (all replicas read, write and update each other) Stand-by (Primary-backup) Replication (Only one replica reads and writes, rest just follow updates from primary) Replication Techniques State Replication Replicated State Machine Change in state is sent to other replicas The operation (event) is executed(applied) to every replica + No need to execute operation again + No need to transmit large state delta - Determining change in state can be complex and large - Operation needs to be executed and must be deterministic Replication and Consensus &amp;hellip;</description></item><item><title>07 - Fault Tolerance</title><link>https://www.digestnotes.com/lectures/lecture07/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/lectures/lecture07/</guid><description>Some Taxonomy Fault-Error-Failure Fault is the problem (software bug, hardware failure) When fault is activated (because buggy part of code is executed), it causes errors Failure is the resulting behaviour Faults: Transient / Intermittent / Permanent Failures: Fail-stop / Timing / Omission / Byzantine Timing: System becomes &amp;ldquo;slow&amp;rdquo; Omission: some actions are missing like msg drops due to memory constraints Managing Failures: Avoidance / Detection / Recovery / Removal Detected failues are either removed by rollback or recovered from.</description></item><item><title>Consistency Tradeoffs</title><link>https://www.digestnotes.com/readings/extra/consistency_tradeoffs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/readings/extra/consistency_tradeoffs/</guid><description>Consistency Tradeoffs in Modern Distributed Database System Design By Daniel J. Abadi The main point that paper tries to put across is this:
Modern DDBS do not provide strong consistency guarantees under normal operations (absense of any faults) not because of CAP theorem but because of consistency-vs-Latency tradeoff. Consistency-vs-Latency tradeoff is more fundamental than CAP theorem because faults like network partitions are usually rare.</description></item><item><title>DSLabs Abstract Interface</title><link>https://www.digestnotes.com/labs/01_framework_abstraction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/labs/01_framework_abstraction/</guid><description>The system consists of a number of nodes which have addresses A Node can send() a message to another node. The receiving node has to handle() the message. Some nodes expose a client interface. An external user can interact with the distributed system by send()ing commandsand gettting results back. Application: Some nodes (server nodes) have contain an application object. An example of an application would be key-value in-memory store. Application is what the users of the distributed system want to access.</description></item><item><title>Message Wrappers</title><link>https://www.digestnotes.com/labs/02_packets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/labs/02_packets/</guid><description>There are my abstractions:
Message Requst and Reply MessageEnvelop Command and Result</description></item><item><title>W07 - Spanner</title><link>https://www.digestnotes.com/readings/spanner/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/readings/spanner/</guid><description>Spanner FAQ MIT 6.824 Distributed Systems
Q: What is time? A: 13:00:00.000 April 7th 2020 UTC is a time. Time advances at a steady rate of one second per second. Q: What is a clock? A: A clock is an oscillator driving a counter. The oscillator should tick at a steady known rate (e.g. one tick per second). The counter must initially be synchronized to a source of the correct time; after that, the oscillator's ticks cause the counter to advance the time.</description></item><item><title>WIP</title><link>https://www.digestnotes.com/labs/dslabs_client_to_server_communication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/labs/dslabs_client_to_server_communication/</guid><description/></item></channel></rss>