<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CS7210 - Distributed Computing</title><link>https://www.digestnotes.com/</link><description>Recent content on CS7210 - Distributed Computing</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 16 Oct 2021 10:30:29 +0530</lastBuildDate><atom:link href="https://www.digestnotes.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Paxos And CAP</title><link>https://www.digestnotes.com/learning/paxos_and_cap/</link><pubDate>Sat, 16 Oct 2021 10:30:29 +0530</pubDate><guid>https://www.digestnotes.com/learning/paxos_and_cap/</guid><description>Paxos and CAP Theorem CAP theorem seems to suggest that under network partition, both consistency and availability cannot be achieved simultaneously. However, Paxos can provide strong consistency even under a network partition. Does it mean that Paxos contradicts CAP theorem?
CAP theorem is known to be misunderstood. There are three points to note. One is that the tradeoff between consistency and availablity only arises under network partition. It means that under normal operation (when there is no network partition) both consistency and availability are achievable.</description></item><item><title>Memcache</title><link>https://www.digestnotes.com/readings/memcache/</link><pubDate>Fri, 15 Oct 2021 06:31:31 +0530</pubDate><guid>https://www.digestnotes.com/readings/memcache/</guid><description>Scaling Memcache at Facebook Content taken from paper and presentation at Scaling Memcache at Facebook NSDI &amp;lsquo;13
Basics Writes Memcache needs to be invalidated after DB write Up to web application to specify which keys to invalidate after database update Reads Two orders of magnitude more reads than writes Common case is data is available in the cache Demand-filled look-aside cache Characteristics of Cache LRU cache Non-authoritative.</description></item><item><title>10 - Consistency and Geo-Distributed Data Stores</title><link>https://www.digestnotes.com/lectures/lecture10/</link><pubDate>Tue, 12 Oct 2021 11:16:52 +0530</pubDate><guid>https://www.digestnotes.com/lectures/lecture10/</guid><description>Consistency and Geo-Distributed Data Stores See notes on Memcache</description></item><item><title>High Availability vs. Fault Tolerance</title><link>https://www.digestnotes.com/learning/high_avail_vs_fault_tolerance/</link><pubDate>Sun, 10 Oct 2021 16:32:34 +0530</pubDate><guid>https://www.digestnotes.com/learning/high_avail_vs_fault_tolerance/</guid><description>High Availability vs. Fault Tolerance source
High Availability aims for your application to run 99.999% of the time. Its design ensures that the entire system can quickly recover if one of its components crashed. It has an ample number of redundant resources to allow failover to another resource if the other one fails. This concept accepts that a failure will occur but provides a way for the system to recover fast.</description></item><item><title>01 - Introduction</title><link>https://www.digestnotes.com/lectures/lecture01/</link><pubDate>Sun, 10 Oct 2021 16:16:01 +0530</pubDate><guid>https://www.digestnotes.com/lectures/lecture01/</guid><description>Introduction to Distributed Systems What is a Distributed System?
A collection of independent and autonomous processes(nodes) that interact by exchanging messages via interconnection network and appear to external users as a single coherent computing facility.
The phrase &amp;ldquo;single coherent computing facility&amp;rdquo; means that there is a common goal which the processes are trying to achieve together.
Simple Model
There nodes which communicate by exchaning messages. Communication channels are unidirectional.</description></item><item><title/><link>https://www.digestnotes.com/labs/lab02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/labs/lab02/</guid><description>Wait-Notify Semantics of Java Java has a builtin wait mechanism that enable threads to become inactive while waiting for signals. The class java.lang.Object defines three methods, wait(), notify(), and notifyAll(), to facilitate this. A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object. In order to call either wait() or notify the calling thread must first obtain the lock on that object.</description></item><item><title>01 DSLabs Abstract Interface</title><link>https://www.digestnotes.com/labs/framework/01_framework_abstraction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/labs/framework/01_framework_abstraction/</guid><description>Important DSLabs Interfaces The system consists of a number of nodes which have addresses A Node can send() a message to another node. The receiving node has to handle() the message. Some nodes expose a client interface. An external user can interact with the distributed system by send()ing commandsand gettting results back. Application: Some nodes (server nodes) have contain an application object. An example of an application would be key-value in-memory store.</description></item><item><title>02 Workload</title><link>https://www.digestnotes.com/labs/framework/02_workload/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/labs/framework/02_workload/</guid><description>Workload abstract class Workload { Pair&amp;lt;Command, Result&amp;gt; nextCommandAndResult() Command nextCommand() boolean hasNext() boolean hasResults() } A workload is an ordered collection of commands and expected results. Results are optional but commands are must. The test framework initializes a Workload and maps it to a client node. The framework executes one command at a time from the Workload on the client. If results are present in the workload, after every command, the result received from the client is compared against the expected result stored in the Workload.</description></item><item><title>03 - Time in D. Systems</title><link>https://www.digestnotes.com/lectures/lecture03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/lectures/lecture03/</guid><description>Time in Distributed Systems Introduction Distributed Systems cannot rely on Physical Clocks so they rely on Logical Clocks Reason: Physical clocks of individual processes need to be synchronized but perfect synchronization is not possible. Why Do We Need Time There are many scenarios in which knowing the time can be helpful. For eg. checking the correctness of the program.</description></item><item><title>03 State Predicates</title><link>https://www.digestnotes.com/labs/framework/03_state_predicates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/labs/framework/03_state_predicates/</guid><description>State Predicate (Invariants) When the framework is running tests, it needs to know whether a test passed or failed. It does so by verifying that certain conditions are met. StatePredicate are those conditions
class StatePredicate extends java.util.Function.Predicate&amp;lt;AbstractState&amp;gt; { String name; Function&amp;lt;AbstractState, Pair&amp;lt;Boolean, String&amp;gt;&amp;gt; predicate; public boolean test(AbstractState state); public String detail(AbstractState state); public StatePredicate negate(); public StatePredicate and(StatePredicate other); public StatePredicate or(StatePredicate other); } java.util.Function.Predicate interface Predicate&amp;lt;T&amp;gt; { boolean test(T t); //default methods default Predicate&amp;lt;T&amp;gt; and(Predicate&amp;lt;?</description></item><item><title>04 - State in D. Systems</title><link>https://www.digestnotes.com/lectures/lecture04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/lectures/lecture04/</guid><description>State in Distributed Systems Terminology The Global State of the system is the union of Process States and Channel States Channel State: The State of a channel between two processes is defined by the set of msgs sent from sender process but yet to be delivered to the receiver. Process State: Context stored on a client for eg variables, data structures etc. Process History: Sequence of events which occured on a process.</description></item><item><title>05 - Consensus</title><link>https://www.digestnotes.com/lectures/lecture05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/lectures/lecture05/</guid><description>Consensus Link to Lecture Slides
Paper Trail: A Brief Tour of FLP Impossibility
Consensus What is Consensus? Ability of processes in a distributed processes to agree on something like the value of a variable, taking an action etc. The problem of consensus is genuinely fundamental to distributed systems research. Getting distributed processors to agree on a value has many, many applications.</description></item><item><title>06 - Replication</title><link>https://www.digestnotes.com/lectures/lecture06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/lectures/lecture06/</guid><description>Replication Goals of Replication State available at more than one node =&amp;gt; Fault-tolerance, Availability Service can be provided from more than one node =&amp;gt; Scalability Replication Modes Active Replication (all replicas read, write and update each other) Stand-by (Primary-backup) Replication (Only one replica reads and writes, rest just follow updates from primary) Replication Techniques State Replication Log Replication or Replicated State Machine Change in state is sent to other replicas The operation (event) is executed(applied) to every replica + No need to execute operation again + No need to transmit large state delta - Determining change in state can be complex and large - Operation needs to be executed and must be deterministic Replication and Consensus When data is replicated over multiple nodes various design choices have to be made Synchronous vs Asynchronous replication Leader based , Multi-leader or Leader-less Strong vs Weak consistency Question: Does synchronous replication imply strong consistency and asynchronous replication imply weak consistency?</description></item><item><title>07 - Fault Tolerance</title><link>https://www.digestnotes.com/lectures/lecture07/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/lectures/lecture07/</guid><description>Fault Tolerance Some Taxonomy Fault-Error-Failure Fault is the problem (software bug, hardware failure) When fault is activated (because buggy part of code is executed), it causes errors Failure is the resulting behaviour Faults: Transient / Intermittent / Permanent Failures: Fail-stop / Timing / Omission / Byzantine Timing: System becomes &amp;ldquo;slow&amp;rdquo; Omission: some actions are missing like msg drops due to memory constraints Managing Failures: Avoidance / Detection / Recovery / Removal Detected failues are either removed by rollback or recovered from.</description></item><item><title>Consistency Tradeoffs</title><link>https://www.digestnotes.com/extra/consistency_tradeoffs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/extra/consistency_tradeoffs/</guid><description>Consistency Tradeoffs in Modern Distributed Database System Design By Daniel J. Abadi The main point that paper tries to put across is this:
Modern DDBS do not provide strong consistency guarantees under normal operations (absense of any faults) not because of CAP theorem but because of consistency-vs-Latency tradeoff. Consistency-vs-Latency tradeoff is more fundamental than CAP theorem because faults like network partitions are usually rare.</description></item><item><title>L03 - Logical Time</title><link>https://www.digestnotes.com/readings/w02_logical_time/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/readings/w02_logical_time/</guid><description>Logical Time: A Way to Capture Causality in Distributed Systems - M. Raynal, M. Singha
A Way to Capture Causality in Distributed Systems Link to Paper
This paper is an easy read and not very long. Moreover, first few pages just repeat the same thing over and over. So, you can read through it in a couple of hours.
Big Ideas
Global/physical clocks don’t work for distributed processes.</description></item><item><title>L04 - Consistent Global States</title><link>https://www.digestnotes.com/readings/w03_consistent_global_states/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/readings/w03_consistent_global_states/</guid><description>Consistent Global States of Distributed Systems Fundamental Concepts and Mechanisms Link to Paper
1 Introduction What is global state of a distributed system?
It is the union of the states of the individual processes.
Why do we study construction of global state?
A large class of problems in distributed computing can be cast as executing some action when the state of the system satisfies a particular condition.</description></item><item><title>Transaction Isolation</title><link>https://www.digestnotes.com/extra/transaction_isolation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/extra/transaction_isolation/</guid><description>Transaction Isolation Links
FundamentalsPrinciples of Distributed Database Systems, Fourth Edition &amp;gt; Appendix C: Transaction Processing What is the difference between Non-Repeatable Read and Phantom Read? - StackOverflow Ch 7: Transactions, Designing Data-Intensive Applications (DDIA) by Martic Kleppmann Transaction Basics: Excerpt from DDIA With the hype around this new crop of distributed databases(NoSQL databases), there emerged a popular belief that transactions were the antithesis of scalability, and that any large-scale system would have to abandon transactions in order to maintain good performance and high availability.</description></item></channel></rss>