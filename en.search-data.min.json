[{"id":0,"href":"/omscs-notes/cs7210/","title":"Cs7210","parent":"CS7210 - Distributed Computing","content":""},{"id":1,"href":"/omscs-notes/","title":"CS7210 - Distributed Computing","parent":"","content":""},{"id":2,"href":"/omscs-notes/cs7210/labs/01_framework_abstraction/","title":"DSLabs Abstract Interface","parent":"Cs7210","content":" The system consists of a number of nodes which have addresses A Node can send() a message to another node. The receiving node has to handle() the message. Some nodes expose a client interface. An external user can interact with the distributed system by send()ing commandsand gettting results back. Application: Some nodes (server nodes) have contain an application object. An example of an application would be key-value in-memory store. Application is what the users of the distributed system want to access. An application takes a command as input and produces result as output. Communication is one way i.e. when a node is sending a message, it is not expecting a reply message. Request/Response semantics are implemented at client-server level.  "},{"id":3,"href":"/omscs-notes/cs7210/lectures/lecture07/","title":"Fault Tolerance","parent":"Cs7210","content":"Fault Tolerance    Some Taxonomy     Fault-Error-Failure  Fault is the problem (software bug, hardware failure) When fault is activated (because buggy part of code is executed), it causes errors Failure is the resulting behaviour   Faults: Transient / Intermittent / Permanent Failures: Fail-stop / Timing / Omission / Byzantine  Timing: System becomes \u0026ldquo;slow\u0026rdquo; Omission: some actions are missing like msg drops due to memory constraints   Managing Failures: Avoidance / Detection / Recovery / Removal  Detected failues are either removed by rollback or recovered from.    Rollback-Recovery     Rollback the system to a state before the failure Rolledback state may not be a real past state. It just needs to be consistent.  Basic Mechanisms     Checkpointing: Save the (full or incremental) state periodically Logging: Log individual write operations.  Undo Log: Log includes original values of variables. This makes it possible to undo an operation. System state can move backward. Redo Log: Log includes new values. To obtain a state, start from beginning and keep applying operations. System state can move forward.    Checkpointing Approaches    System Model\n Network is non-partitionable. Why ?? FIFO / communication channel reliability and num of failures will vary with protocol.  Uncoordinated Approach\n Processes take checkpoints independently. Problems  The failed node rollbacks to previous checkpoint. If the state of the whole system becomes inconsistent, more rollbacks may have to be performed at several nodes =\u0026gt; Domino effect. Leads to multiple useless checkpoints.    Coordinated Checkpoint\n Processes coordinate to take a consistent snapshot. Problems  How to coordinate? No synchronous clock guarantee ie no global clock. (Everybody take snapshot at 5pm) If msg delivery was reliable with bounded delay, some approach could be created.    Communication induced Checkpoint\n Use a consensus protocol: All nodes should reach a consensus that a snapshot will be taken and that they will not send any msg till it\u0026rsquo;s complete. In a way, it\u0026rsquo;s a blocking protocol. A non-blocking algo will be similar to Global Snapshot algo but it requires FIFO communication channel.  Logging\n When reconstructing state we must ensure that it\u0026rsquo;s not a inconsistent state. A crashed process might not log the last event it sent. We might apply events in wrong order. Pessimistic: First log the event then send it. Optimistic: Assume log will be persisted but make it possible to remove it\u0026rsquo;s effect if aborted Causalty-tracking: ensure causality related events are deterministically recorded  Which Method to Use?\n Workload characteristics: Frequency of updatss, size of updates, Failures characteristics: System Characteristics: cost of communication/stoage, system scale,  "},{"id":4,"href":"/omscs-notes/cs7210/labs/02_packets/","title":"Message Wrappers","parent":"Cs7210","content":"There are my abstractions:\n Message Requst and Reply MessageEnvelop Command and Result  "},{"id":5,"href":"/omscs-notes/cs7210/lectures/lecture06/","title":"Replication","parent":"Cs7210","content":"Replication    Goals of Replication     State available at more than one node =\u0026gt; Fault-tolerance, Availability Service can be provided from more than one node =\u0026gt; Scalability  Replication Modes     Active Replication (all replicas read, write and update each other) Stand-by (Primary-backup) Replication (Only one replica reads and writes, rest just follow updates from primary)  Replication Techniques       State Replication Replicated State Machine     Change in state is sent to other replicas The operation (event) is executed(applied) to every replica   + No need to execute operation again + No need to transmit large state delta   - Determining change in state can be complex and large - Operation needs to be executed and must be deterministic    Replication and Consensus    \u0026hellip;\nChain Replication     Lag in replication increases linearly with number of replicas Another option (van Renesse, Schneider, OSDI'14) is to do a synchronous replication.  "},{"id":6,"href":"/omscs-notes/tags/","title":"Tags","parent":"CS7210 - Distributed Computing","content":""},{"id":7,"href":"/omscs-notes/cs7210/labs/dslabs_client_to_server_communication/","title":"WIP","parent":"Cs7210","content":""}]