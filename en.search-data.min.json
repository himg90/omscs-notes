[{"id":0,"href":"/","title":"CS7210 - Distributed Computing","parent":"","content":""},{"id":1,"href":"/labs/lab04/","title":"Lab04 - Paxos","parent":"Labs","content":"Project 5 Paxos    Understanding Paxos    The main reference provided for this lab is Paxos Made Moderately Complex. The paper is long but it\u0026rsquo;s readable. An alternative to the paper is this article by the same authors. The article, however, only covers upto section 3 of the paper.\nBefore reading the paper, I would recommend understanding paxos and multi-paxos. For Paxos, I would recommend watching L9: Paxos Simplified by Chris Colohan. The explaination for Paxos starts from time 11:58. Next, for multi-panos, watch Paxos lecture (Raft user study)  by Diego Ongaro. In fact, you can watch this video for both Paxos and Multi-Paxos.\n"},{"id":2,"href":"/labs/","title":"Labs","parent":"CS7210 - Distributed Computing","content":"    Lab02     DSLabs Framework     01 DSLabs Abstract Interface     02 Workload     03 State Predicates       Lab04 - Paxos     Some useful links about virtual box\n What is VirtualBox closed source and VirtualBox OSE? https://wiki.debian.org/VirtualBox https://blogs.oracle.com/virtualization/friday-spotlight:-virtualbox-extension-pack-guest-additions#  "},{"id":3,"href":"/labs/lab02/","title":"Lab02","parent":"Labs","content":"Wait-Notify Semantics of Java     Java has a builtin wait mechanism that enable threads to become inactive while waiting for signals. The class java.lang.Object defines three methods, wait(), notify(), and notifyAll(), to facilitate this. A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object. In order to call either wait() or notify the calling thread must first obtain the lock on that object. In other words, the calling thread must call wait() or notify() from inside a synchronized block.\n source: Thread Signaling by Jakob Jenkov\nSynchronized Instance Methods in Java     A synchronized instance method in Java is synchronized on the instance (object) owning the method. Thus, each instance has its synchronized methods synchronized on a different object: the owning instance. Only one thread per instance can execute inside a synchronized instance method. If more than one instance exist, then one thread at a time can execute inside a synchronized instance method per instance. One thread per instance. This is true across all synchronized instance methods for the same object (instance). Thus, in the following example, only one thread can execute inside either of of the two synchronized methods. One thread in total per instance.\n source: Java Synchronized Blocks by Jakob Jenkov\n"},{"id":4,"href":"/labs/framework/01_framework_abstraction/","title":"01 DSLabs Abstract Interface","parent":"DSLabs Framework","content":"Important DSLabs Interfaces     The system consists of a number of nodes which have addresses A Node can send() a message to another node. The receiving node has to handle() the message. Some nodes expose a client interface. An external user can interact with the distributed system by send()ing commandsand gettting results back. Application: Some nodes (server nodes) have contain an application object. An example of an application would be key-value in-memory store. Application is what the users of the distributed system want to access. An application takes a command as input and produces result as output. Communication is one way i.e. when a node is sending a message, it is not expecting a reply message. Request/Response semantics are implemented at client-server level.  "},{"id":5,"href":"/labs/framework/02_workload/","title":"02 Workload","parent":"DSLabs Framework","content":"Workload    abstract class Workload { Pair\u0026lt;Command, Result\u0026gt; nextCommandAndResult() Command nextCommand() boolean hasNext() boolean hasResults() }  A workload is an ordered collection of commands and expected results. Results are optional but commands are must. The test framework initializes a Workload and maps it to a client node. The framework executes one command at a time from the Workload on the client. If results are present in the workload, after every command, the result received from the client is compared against the expected result stored in the Workload.  StandardWorkload      It\u0026rsquo;s a concrete implementation of Workload.\n  It adds two capabilities to Workload\n  Repetition: The workload ( i.e. the command in workload) can be executed specified number of times.\n  Patterns as Commands: Instead of providing exact list of command objects, it can be provided with a string patterns and it transforms them into strings. These strings are then converted to Command and Result objects by Parser. Parser is nothing but a function that takes strings as input and converts them to Command and Result Objects.\n String_Pattern \u0026#34;GET:foo_%i\u0026#34; | v +-------------------+ | Standard Workload | | doReplacements() | +-------------------+ | v +--------------+ String_Command -------\u0026gt; |Parser |-------\u0026gt; GET{ GET:foo_01 |KVStoreParser | key : \u0026#34;foo_01\u0026#34;} +--------------+     "},{"id":6,"href":"/labs/framework/03_state_predicates/","title":"03 State Predicates","parent":"DSLabs Framework","content":"State Predicate (Invariants)    When the framework is running tests, it needs to know whether a test passed or failed. It does so by verifying that certain conditions are met. StatePredicate are those conditions\nclass StatePredicate extends java.util.Function.Predicate\u0026lt;AbstractState\u0026gt; { String name; Function\u0026lt;AbstractState, Pair\u0026lt;Boolean, String\u0026gt;\u0026gt; predicate; public boolean test(AbstractState state); public String detail(AbstractState state); public StatePredicate negate(); public StatePredicate and(StatePredicate other); public StatePredicate or(StatePredicate other); } java.util.Function.Predicate    interface Predicate\u0026lt;T\u0026gt; { boolean test(T t); //default methods  default Predicate\u0026lt;T\u0026gt; and(Predicate\u0026lt;? super T\u0026gt; other); default Predicate\u0026lt;T\u0026gt; negate(); default Predicate\u0026lt;T\u0026gt; or(Predicate\u0026lt;? super T\u0026gt; other); }  Predicate is a standard java interface with just one abstract method signature. bool test(T) . It takes a generic T as input and produces bool as output. For any testing framework this can be a useful interface. The framework\u0026rsquo;s \u0026ldquo;conditions\u0026rdquo; should implement this interface. They take state of the system as input to test(). Then test() executes some logic and produces the result indicating whether it was a pass or a fail.  Adding Names and Messages    StatePredicate class adds two more things\n It stores a human readable name for the \u0026ldquo;condition\u0026rdquo; Along with returning whether condition was met or not, it also returns a small message indicating success or why there was a failure.   +--------------+ +-------------+ | | +----------------+ | | |AbstractState |----------\u0026gt; | StatePredicate |-------\u0026gt; |\u0026lt;bool_result, |(State of the | | predicate() | |string_msg\u0026gt; | | System) | +----------------+ | | +--------------+ +-------------+ Links\nhttps://piazza.com/class/krwk6s0eadh2yh?cid=191\n"},{"id":7,"href":"/labs/framework/","title":"DSLabs Framework","parent":"Labs","content":"    01 DSLabs Abstract Interface     02 Workload     03 State Predicates     "},{"id":8,"href":"/tags/","title":"Tags","parent":"CS7210 - Distributed Computing","content":""}]