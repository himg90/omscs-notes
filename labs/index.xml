<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Labs on CS7210 - Distributed Computing</title><link>https://www.digestnotes.com/labs/</link><description>Recent content in Labs on CS7210 - Distributed Computing</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 17 Oct 2021 10:54:22 +0530</lastBuildDate><atom:link href="https://www.digestnotes.com/labs/index.xml" rel="self" type="application/rss+xml"/><item><title>Lab04 - Paxos</title><link>https://www.digestnotes.com/labs/lab04/</link><pubDate>Sun, 17 Oct 2021 10:54:22 +0530</pubDate><guid>https://www.digestnotes.com/labs/lab04/</guid><description>Project 5 Paxos Understanding Paxos The main reference provided for this lab is Paxos Made Moderately Complex. The paper is long but it&amp;rsquo;s readable. An alternative to the paper is this article by the same authors. The article, however, only covers upto section 3 of the paper.
Before reading the paper, I would recommend understanding paxos and multi-paxos. For Paxos, I would recommend watching L9: Paxos Simplified by Chris Colohan.</description></item><item><title/><link>https://www.digestnotes.com/labs/lab02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/labs/lab02/</guid><description>Wait-Notify Semantics of Java Java has a builtin wait mechanism that enable threads to become inactive while waiting for signals. The class java.lang.Object defines three methods, wait(), notify(), and notifyAll(), to facilitate this. A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object. In order to call either wait() or notify the calling thread must first obtain the lock on that object.</description></item></channel></rss>