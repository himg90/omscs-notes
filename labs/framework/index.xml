<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DSLabs Framework on CS7210 - Distributed Computing</title><link>https://www.digestnotes.com/labs/framework/</link><description>Recent content in DSLabs Framework on CS7210 - Distributed Computing</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://www.digestnotes.com/labs/framework/index.xml" rel="self" type="application/rss+xml"/><item><title>WIP</title><link>https://www.digestnotes.com/labs/framework/dslabs_client_to_server_communication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/labs/framework/dslabs_client_to_server_communication/</guid><description>Route of a Command</description></item><item><title>01 DSLabs Abstract Interface</title><link>https://www.digestnotes.com/labs/framework/01_framework_abstraction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/labs/framework/01_framework_abstraction/</guid><description>Important DSLabs Interfaces The system consists of a number of nodes which have addresses A Node can send() a message to another node. The receiving node has to handle() the message. Some nodes expose a client interface. An external user can interact with the distributed system by send()ing commandsand gettting results back. Application: Some nodes (server nodes) have contain an application object. An example of an application would be key-value in-memory store.</description></item><item><title>02 Workload</title><link>https://www.digestnotes.com/labs/framework/02_workload/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/labs/framework/02_workload/</guid><description>Workload abstract class Workload { Pair&amp;lt;Command, Result&amp;gt; nextCommandAndResult() Command nextCommand() boolean hasNext() boolean hasResults() } A workload is an ordered collection of commands and expected results. Results are optional but commands are must. The test framework initializes a Workload and maps it to a client node. The framework executes one command at a time from the Workload on the client. If results are present in the workload, after every command, the result received from the client is compared against the expected result stored in the Workload.</description></item><item><title>03 State Predicates</title><link>https://www.digestnotes.com/labs/framework/03_state_predicates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.digestnotes.com/labs/framework/03_state_predicates/</guid><description>State Predicate (Invariants) When the framework is running tests, it needs to know whether a test passed or failed. It does so by verifying that certain conditions are met. StatePredicate are those conditions
class StatePredicate extends java.util.Function.Predicate&amp;lt;AbstractState&amp;gt; { String name; Function&amp;lt;AbstractState, Pair&amp;lt;Boolean, String&amp;gt;&amp;gt; predicate; public boolean test(AbstractState state); public String detail(AbstractState state); public StatePredicate negate(); public StatePredicate and(StatePredicate other); public StatePredicate or(StatePredicate other); } java.util.Function.Predicate interface Predicate&amp;lt;T&amp;gt; { boolean test(T t); //default methods default Predicate&amp;lt;T&amp;gt; and(Predicate&amp;lt;?</description></item></channel></rss>